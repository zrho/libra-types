# Type Classes

A function with a polymorphic argument must work with values of any type.
This is fine for a function like `rev: ∀a. List a -> List a` that reverse a
list without looking at its elements.
However some polymorphic functions might need to assume additional stucture
on their type arguments.
A sorting function for lists can not be given the type `∀a. List a -> List a`
since it requires the type `a` to be ordered.
This can be expressed via type class `Ord`, giving the sort function the type
`∀a. Ord a => List a -> List a`.

Type classes can be expressed naturally using Libra's constraint system.

## Instantiation

Suppose that we encounter the `sort` function in the constraint generation
phase of the type inference algorithm. We look up the type schema of `sort`
in the environment and find it to be `∀a. Ord a => List a -> List a`.
We instantiate the type parameter `a` with a new type variable `?0` and
recursively insert the `List` and `->` type constructors into the `TypeSet` as usual.
The type class constraint `Ord a` then translates into a new constraint `Ord ?0`
in the typeset. Overall, we have inserted five new entries:

```txt
?0
?1 = List ?0
?2 = List ?0
?3 = -> ?0 ?1
?4 = Ord ?0
```

## Solving

In the instantiation step, a type class constraint is translated into a constraint
in the `TypeSet`. The constraint starts out as active and therefore will at some
point show up in the solver loop.

When the type of the constraint's argument has become concrete enough,
we might be able to solve the constraint directly. For example, when we see
a constraint `Ord ?0` and `?0` is bound to `Int`, we can mark the constraint
as solved after assuring ourselves that `Int`s can be ordered. Otherwise,
the constraint becomes deferred, to be considered again once more information
is available.

 - **TODO** Implication

`Ord a, Ord b => Ord (Pair a b)`.
In this case, when we encounter a constraint `Ord (Pair ?0 ?1)` we can immediately
solve it by inserting new constraints `Ord ?0` and `Ord ?1` into the type set.


At this point we may also perform deduplication:
When we notice that a type is constrained multiple times by the same type class,
we can unify the constraints. This is possible since constraints are themselves
just type constructors in the `TypeSet`.
By deduplicating the constraints, we avoid solving them multiple times,
which might be helpful for deeply nested generic types.
Deduplication is also important for subsumption checking and evidence translation.

 - **TODO** What happens with the constaint's state after unification?
 
## Subsumption

 - **TODO** Subsumption
 - **TODO** Write about unconstrained subsumption before (requires skolem vars).

`(∀a. Eq a => a -> bool) <= (∀a. Ord a => a -> bool)`

Recall that the subsumption relation requires that we
can use a `∀a. Eq a => a -> bool` whereever we expect an `∀a. Ord a => a -> bool`.
The two type class constraints must be handled differently:
The `Eq a` constraint on the left is a goal that we need to prove,
while `Ord a` is an assumption that we are allowed to make.
Since `Ord a` implies `Eq a`, the `Eq a` constraint can be discharged and the subsumption is valid.

Let us go through this example in detail to see how Libra can check the subsumption:
We begin by instantiating the type scheme on the left, generating an additional
skolem constraint for `a` as we did for subsumption without type classes:

```txt
?0 [type variable a on the left hand side]
?1 = bool
?2 = -> ?0 ?1
?3 = Eq ?0
?4 = Skolem ?0
```

We then instantiate the type scheme on the right.
This time we mark `Ord ?4` as solved.
```txt
?4 [type variable a on the right hand side]
?5 = bool
?6 = -> ?4 ?5
?7 = Ord ?4 [solved]
?8 = Eq ?4 [solved]
```

 - **TODO**: Is `?8 = Eq ?4` generated by the same mechanism as usual?

When unifying `?2 = -> ?0 ?1` and `?6 = -> ?4 ?5`
we also unify the type variables `?0` and `?4`. 
As a consequence `?3 = Eq ?0` and `?8 = Eq ?4` become duplicates and are
unified. Since `?8 = Eq ?4` was solved, the unified constraint is solved as well.
 
## Evidence translation
 
 - **TODO** Evidence translation
